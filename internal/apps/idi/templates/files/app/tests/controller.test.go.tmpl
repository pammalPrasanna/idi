package {{.AppName}}_test

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/http/httptest"
	"testing"
	"time"

	rest "{{.ProjectName}}/internal/apps/{{.AppName}}/internal/adapters/httprouter"
	"{{.ProjectName}}/internal/dtos"
	"{{.ProjectName}}/internal/lib"
	"{{.ProjectName}}/internal/apps/{{.AppName}}/internal/adapters/sqlite3"
	"{{.ProjectName}}/internal/apps/{{.AppName}}/internal/application"
	
	"github.com/google/go-cmp/cmp"
	"github.com/golang/mock/gomock"
	"github.com/julienschmidt/httprouter"
	"github.com/stretchr/testify/assert"
)

// GET /{{.AppName}}
// 200, 500

// GET /{{.AppName}}/:id
// 200, 404, 422, 500

// PUT /{{.AppName}}/:id
// 200, 400, 422, 500

// DELETE /{{.AppName}}/:id
// 200, 404, 422, 500

// Authentication tests

type handlerTests struct {
	url    string
	method string
	tests  []restTc
}

type restTc struct {
	body           []byte
	tcName         string
	schema         string
	targetUrl      string
	expectedStatus int
	mockReturns    []any
}


func createInvalid{{capitalize (trimS .AppName)}}Bytes(t *testing.T) []byte {
	uj, err := json.Marshal(&dtos.Create{{capitalize (trimS .AppName)}}Params{
		Username: "",
		{{if eq .AppName "users"}}
		Email:    "",
		Password: "",
		{{end}}

	})
	assert.Nil(t, err)
	return uj
}

func createValid{{capitalize (trimS .AppName)}}Bytes(t *testing.T) []byte {
	uj, err := json.Marshal(&dtos.Create{{capitalize (trimS .AppName)}}Params{
		Username: randString(5),
		{{if eq .AppName "users"}}
		Email:    randomEmail(),
		Password: randString(8),
		{{end}}
	})
	assert.Nil(t, err)
	return uj
}


func createRESTTestCases(t *testing.T) []handlerTests {
	t.Helper()

	valid{{capitalize (trimS .AppName)}} := createValid{{capitalize (trimS .AppName)}}(t)
	valid{{capitalize (trimS .AppName)}}Json, err := json.Marshal(valid{{capitalize (trimS .AppName)}})
	assert.Nil(t, err)

	created{{capitalize (trimS .AppName)}} := &dtos.{{capitalize (trimS .AppName)}}{
		ID:        1,
		Username:  randString(5),
		{{if eq .AppName "{{.AppName}}"}}
		Email:     randomEmail(),
		{{end}}
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}
	tc := []handlerTests{
		{
			url:    "/{{.AppName}}",
			method: http.MethodGet,
			// GET /{{.AppName}}
			// 200, 200, 500
			tests: []restTc{
				{
					tcName:         "find {{.AppName}} empty list",
					schema:         find{{capitalize .AppName}}Schema200,
					expectedStatus: http.StatusOK,
					targetUrl:      "/{{.AppName}}",
					mockReturns:    []any{[]*dtos.{{capitalize (trimS .AppName)}}{}, nil},
				},
				{
					tcName:         "find {{.AppName}} with data",
					schema:         find{{capitalize .AppName}}Schema200,
					expectedStatus: http.StatusOK,
					targetUrl:      "/{{.AppName}}",
					mockReturns:    []any{[]*dtos.{{capitalize (trimS .AppName)}}{created{{capitalize (trimS .AppName)}}}, nil},
				},
				{
					tcName:         "internal server error",
					schema:         {{trimS .AppName}}Schema500,
					expectedStatus: http.StatusInternalServerError,
					targetUrl:      "/{{.AppName}}",
					mockReturns:    []any{nil, errors.New("")},
				},
			},
		},
		{
			url:    "/{{.AppName}}/:id",
			method: http.MethodGet,
			// GET /{{.AppName}}/:id
			// 200, 404, 422, 500
			tests: []restTc{
				{
					tcName:         "get {{trimS .AppName}} with id",
					schema:         get{{capitalize (trimS .AppName)}}Schema200,
					expectedStatus: http.StatusOK,
					targetUrl:      "/{{.AppName}}/1",
					mockReturns:    []any{&dtos.{{capitalize (trimS .AppName)}}{ID: 1, Username: "qwer", Email: randomEmail(), CreatedAt: time.Now(), UpdatedAt: time.Now()}, nil},
				},
				{
					tcName:         "record not found",
					schema:         {{trimS .AppName}}Schema404,
					expectedStatus: http.StatusNotFound,
					targetUrl:      "/{{.AppName}}/10000",
					mockReturns:    []any{nil, lib.ErrNoRecord},
				},
				{
					tcName:         "invalid id",
					schema:         {{trimS .AppName}}SchemaInvalidID422,
					expectedStatus: http.StatusUnprocessableEntity,
					targetUrl:      "/{{.AppName}}/{{.ProjectName}}",
					mockReturns:    nil,
				},
				{
					tcName:         "internal server error",
					schema:         {{trimS .AppName}}Schema500,
					expectedStatus: http.StatusInternalServerError,
					targetUrl:      "/{{.AppName}}/1",
					mockReturns:    []any{nil, errors.New("")},
				},
			},
		},
		{
			url:    "/{{.AppName}}",
			method: http.MethodPost,
			// POST /{{.AppName}}
			// 201, 400, 422, 500
			tests: []restTc{
				{
					tcName:         "create {{trimS .AppName}}",
					schema:         post{{trimS .AppName}}Schema201,
					expectedStatus: http.StatusCreated,
					body:           valid{{capitalize (trimS .AppName)}}Json,
					targetUrl:      "/{{.AppName}}",
					mockReturns:    []any{int64(1), nil},
				},
				{
					tcName:         "malformed json",
					schema:         {{trimS .AppName}}Schema400,
					expectedStatus: http.StatusBadRequest,
					targetUrl:      "/{{.AppName}}",
					mockReturns:    []any{int64(1), nil},
					body:           []byte(`{"username":}`),
				},
				{
					tcName:         "validation errors",
					schema:         {{trimS .AppName}}Schema422,
					expectedStatus: http.StatusUnprocessableEntity,
					targetUrl:      "/{{.AppName}}",
					mockReturns: []any{
						int64(-1), lib.ErrInvalidData{
							"username": []string{},
							{{if eq .AppName "users"}}
							"email":    []string{},
							"password": []string{},
							{{end}}
						},
					},
					body: createInvalid{{capitalize (trimS .AppName)}}Bytes(t),
				},
				{
					tcName:         "internal server error",
					schema:         {{trimS .AppName}}Schema500,
					expectedStatus: http.StatusInternalServerError,
					targetUrl:      "/{{.AppName}}",
					mockReturns:    []any{int64(-1), errors.New("")},
					body:           valid{{capitalize (trimS .AppName)}}Json,
				},
			},
		},
		{
			url:    "/{{.AppName}}/:id",
			method: http.MethodPatch,
			// 200, 400, 404, 422, 500
			tests: []restTc{
				{
					tcName:         "successful patch",
					schema:         patch{{capitalize (trimS .AppName)}}Schema200,
					expectedStatus: http.StatusOK,
					body:           valid{{capitalize (trimS .AppName)}}Json,
					targetUrl:      "/{{.AppName}}/1",
					mockReturns:    []any{nil},
				},
				{
					tcName:         "malformed json",
					schema:         {{trimS .AppName}}Schema400,
					expectedStatus: http.StatusBadRequest,
					targetUrl:      "/{{.AppName}}/1",
					mockReturns:    []any{nil},
					body:           []byte(`{"username":}`),
				},
				{
					tcName:         "record not found",
					schema:         {{trimS .AppName}}Schema404,
					expectedStatus: http.StatusNotFound,
					targetUrl:      "/{{.AppName}}/10000",
					mockReturns:    []any{lib.ErrNoRecord},
					body:           createInvalid{{capitalize (trimS .AppName)}}Bytes(t),
				},
				{
					tcName:         "invalid id",
					schema:         {{trimS .AppName}}SchemaInvalidID422,
					expectedStatus: http.StatusUnprocessableEntity,
					targetUrl:      "/{{.AppName}}/-1",
					mockReturns:    []any{nil},
					body:           createInvalid{{capitalize (trimS .AppName)}}Bytes(t),
				},
				{
					tcName:         "validation errors",
					schema:         {{trimS .AppName}}Schema422,
					expectedStatus: http.StatusUnprocessableEntity,
					targetUrl:      "/{{.AppName}}/1",
					mockReturns: []any{
						lib.ErrInvalidData{
							"username": []string{},
							{{if eq .AppName "users"}}
							"email":    []string{},
							"password": []string{},
							{{end}}
						},
					},
					body: createInvalid{{capitalize (trimS .AppName)}}Bytes(t),
				},
				{
					tcName:         "internal server error",
					schema:         {{trimS .AppName}}Schema500,
					expectedStatus: http.StatusInternalServerError,
					targetUrl:      "/{{.AppName}}/1",
					mockReturns:    []any{errors.New("")},
					body:           valid{{capitalize (trimS .AppName)}}Json,
				},
			},
		},
		{
			url:    "/{{.AppName}}/:id",
			method: http.MethodDelete,
			// 200, 400, 404, 422, 500
			tests: []restTc{
				{
					tcName:         "successful delete",
					schema:         delete{{capitalize (trimS .AppName)}}Schema200,
					expectedStatus: http.StatusOK,
					targetUrl:      "/{{.AppName}}/1",
					mockReturns:    []any{nil},
				},
				{
					tcName:         "no record found",
					schema:         {{trimS .AppName}}Schema404,
					expectedStatus: http.StatusNotFound,
					targetUrl:      "/{{.AppName}}/10000",
					mockReturns:    []any{lib.ErrNoRecord},
				},
				{
					tcName:         "invalid id",
					schema:         {{trimS .AppName}}SchemaInvalidID422,
					expectedStatus: http.StatusUnprocessableEntity,
					targetUrl:      "/{{.AppName}}/-1",
					mockReturns:    []any{nil},
					body:           createInvalid{{capitalize (trimS .AppName)}}Bytes(t),
				},
				{
					tcName:         "internal server error",
					schema:         {{trimS .AppName}}Schema500,
					expectedStatus: http.StatusInternalServerError,
					targetUrl:      "/{{.AppName}}/1",
					mockReturns:    []any{errors.New("")},
					body:           valid{{capitalize (trimS .AppName)}}Json,
				},
			},
		},
	}

	return tc
}

func createNewRequest(t *testing.T, method, url string, body []byte) *http.Request {
	t.Helper()
	if body != nil {
		return httptest.NewRequest(method, url, bytes.NewReader(body))
	}
	return httptest.NewRequest(method, url, nil)
}

func getResponseBody(t *testing.T, w *httptest.ResponseRecorder) []byte {
	t.Helper()

	body, err := io.ReadAll(w.Result().Body)
	assert.Nil(t, err, "want nil")
	defer w.Result().Body.Close()

	return body
}


func Test{{capitalize .AppName}}Controller(t *testing.T) {
	t.Parallel()
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	for _, handler := range createRESTTestCases(t) {
		for _, tc := range handler.tests {
			t.Run(fmt.Sprintf("-- SchemaValidation | %s  | %s %s - %d", tc.tcName, handler.method, handler.url, tc.expectedStatus), func(t *testing.T) {
				t.Parallel()
				mockApp := NewMockI{{capitalize .AppName}}(ctrl)
				{{.AppName}}Controller := rest.New{{capitalize .AppName}}Controller(rootApp, mockApp)

				router := httprouter.New()

				switch {
				case handler.method == http.MethodGet && handler.url == "/{{.AppName}}":
					router.HandlerFunc(handler.method, handler.url, {{.AppName}}Controller.Find{{capitalize .AppName}}H)
					if tc.mockReturns != nil {
						mockApp.EXPECT().Find{{capitalize .AppName}}(gomock.Any(), gomock.Any()).Return(tc.mockReturns...).Times(1)
					}
				case handler.method == http.MethodGet && handler.url == "/{{.AppName}}/:id":
					router.HandlerFunc(handler.method, handler.url, {{.AppName}}Controller.Get{{capitalize (trimS .AppName)}}H)
					if tc.mockReturns != nil {
						mockApp.EXPECT().Get{{capitalize (trimS .AppName)}}(gomock.Any(), gomock.Any()).Return(tc.mockReturns...).Times(1)
					}

				case handler.method == http.MethodPost && handler.url == "/{{.AppName}}":
					router.HandlerFunc(handler.method, handler.url, {{.AppName}}Controller.Create{{capitalize (trimS .AppName)}}H)
					if tc.mockReturns != nil {
						mockApp.EXPECT().Create{{capitalize (trimS .AppName)}}(gomock.Any(), gomock.Any()).Return(tc.mockReturns...).Times(1)
					}
				case handler.method == http.MethodPatch && handler.url == "/{{.AppName}}/:id":
					router.HandlerFunc(handler.method, handler.url, {{.AppName}}Controller.Patch{{capitalize (trimS .AppName)}}H)
					if tc.mockReturns != nil {
						mockApp.EXPECT().Update{{capitalize (trimS .AppName)}}(gomock.Any(), gomock.Any()).Return(tc.mockReturns...).Times(1)
					}

				case handler.method == http.MethodDelete && handler.url == "/{{.AppName}}/:id":
					router.HandlerFunc(handler.method, handler.url, {{.AppName}}Controller.Delete{{capitalize (trimS .AppName)}}H)
					if tc.mockReturns != nil {
						mockApp.EXPECT().Delete{{capitalize (trimS .AppName)}}(gomock.Any(), gomock.Any()).Return(tc.mockReturns...).Times(1)
					}
				}

				w := httptest.NewRecorder()
				r := createNewRequest(t, handler.method, tc.targetUrl, tc.body)

				router.ServeHTTP(w, r)

				gotStatus := w.Result().StatusCode
				assert.Equalf(t, tc.expectedStatus, gotStatus, "tc: '%s' | %s %s | want %d, got %d", tc.tcName, handler.method, tc.targetUrl, tc.expectedStatus, gotStatus)

				body, err := io.ReadAll(w.Result().Body)
				assert.Nil(t, err, "want nil")

				validateSchema(t, tc.schema, body)
			})
		}
	}
}

func Test{{capitalize .AppName}}ControllerAPIIntegration(t *testing.T) {
	t.Parallel()
	if !INTEGRATION_TESTS {
		t.Errorf("skipping tests | INTEGRATION_TESTS = '%v'", INTEGRATION_TESTS)
		t.FailNow()
	}

	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	repo := sqlite3.NewRepository(dbConn, NewMockILogger(ctrl))
	{{.AppName}}App := application.New(rootApp, repo)
	{{.AppName}}Controller := rest.New{{capitalize .AppName}}Controller(rootApp, {{.AppName}}App)

	router := httprouter.New()
	router.HandlerFunc(http.MethodGet, "/{{.AppName}}", {{.AppName}}Controller.Find{{capitalize .AppName}}H)
	router.HandlerFunc(http.MethodPost, "/{{.AppName}}", {{.AppName}}Controller.Create{{capitalize (trimS .AppName)}}H)
	router.HandlerFunc(http.MethodGet, "/{{.AppName}}/:id", {{.AppName}}Controller.Get{{capitalize (trimS .AppName)}}H)
	router.HandlerFunc(http.MethodPatch, "/{{.AppName}}/:id", {{.AppName}}Controller.Patch{{capitalize (trimS .AppName)}}H)
	router.HandlerFunc(http.MethodDelete, "/{{.AppName}}/:id", {{.AppName}}Controller.Delete{{capitalize (trimS .AppName)}}H)

	// find {{.AppName}}
	rec := httptest.NewRecorder()
	router.ServeHTTP(rec, createNewRequest(t, http.MethodGet, "/{{.AppName}}", nil))

	assert.Equal(t, http.StatusOK, rec.Result().StatusCode)
	validateSchema(t, find{{capitalize .AppName}}Schema200, getResponseBody(t, rec))

	// create invalid {{trimS .AppName}}
	rec = httptest.NewRecorder()
	req := createNewRequest(t, http.MethodPost, "/{{.AppName}}", createInvalid{{capitalize (trimS .AppName)}}Bytes(t))
	router.ServeHTTP(rec, req)

	assert.Equal(t, http.StatusUnprocessableEntity, rec.Result().StatusCode)
	validateSchema(t, {{trimS .AppName}}Schema422, getResponseBody(t, rec))

	// create valid {{trimS .AppName}}
	rec = httptest.NewRecorder()
	router.ServeHTTP(rec, createNewRequest(t, http.MethodPost, "/{{.AppName}}", createValid{{capitalize (trimS .AppName)}}Bytes(t)))

	assert.Equal(t, http.StatusCreated, rec.Result().StatusCode)
	respBody := getResponseBody(t, rec)
	validateSchema(t, post{{trimS .AppName}}Schema201, respBody)

	var cup *rest.Create{{capitalize (trimS .AppName)}}Response
	assert.Nil(t, json.Unmarshal(respBody, &cup))

	// get the created {{trimS .AppName}}
	rec = httptest.NewRecorder()
	router.ServeHTTP(rec, createNewRequest(t, http.MethodGet, fmt.Sprintf("/{{.AppName}}/%d", cup.{{capitalize (trimS .AppName)}}ID), nil))

	assert.Equal(t, http.StatusOK, rec.Result().StatusCode)
	respBody = getResponseBody(t, rec)
	validateSchema(t, get{{capitalize (trimS .AppName)}}Schema200, respBody)

	var created{{capitalize (trimS .AppName)}} *rest.Get{{capitalize (trimS .AppName)}}Response
	assert.Nil(t, json.Unmarshal(respBody, &created{{capitalize (trimS .AppName)}}))

	// update {{trimS .AppName}}
	rec = httptest.NewRecorder()
	router.ServeHTTP(rec, createNewRequest(t, http.MethodPatch, fmt.Sprintf("/{{.AppName}}/%d", created{{capitalize (trimS .AppName)}}.{{capitalize (trimS .AppName)}}.ID), createValid{{capitalize (trimS .AppName)}}Bytes(t)))
	assert.Equal(t, http.StatusOK, rec.Result().StatusCode, fmt.Sprintf("/{{.AppName}}/%d", created{{capitalize (trimS .AppName)}}.{{capitalize (trimS .AppName)}}.ID), created{{capitalize (trimS .AppName)}})
	validateSchema(t, patch{{capitalize (trimS .AppName)}}Schema200, getResponseBody(t, rec))

	// verify the update
	rec = httptest.NewRecorder()
	router.ServeHTTP(rec, createNewRequest(t, http.MethodGet, fmt.Sprintf("/{{.AppName}}/%d", created{{capitalize (trimS .AppName)}}.{{capitalize (trimS .AppName)}}.ID), nil))
	assert.Equal(t, http.StatusOK, rec.Result().StatusCode)
	respBody = getResponseBody(t, rec)
	validateSchema(t, get{{capitalize (trimS .AppName)}}Schema200, respBody)

	var updated{{capitalize (trimS .AppName)}} *rest.Get{{capitalize (trimS .AppName)}}Response
	assert.Nil(t, json.Unmarshal(respBody, &updated{{capitalize (trimS .AppName)}}))
	assert.NotEqual(t, "", cmp.Diff(created{{capitalize (trimS .AppName)}}, updated{{capitalize (trimS .AppName)}}))

	// delete the {{trimS .AppName}}
	rec = httptest.NewRecorder()
	router.ServeHTTP(rec, createNewRequest(t, http.MethodDelete, fmt.Sprintf("/{{.AppName}}/%d", created{{capitalize (trimS .AppName)}}.{{capitalize (trimS .AppName)}}.ID), nil))
	assert.Equal(t, http.StatusOK, rec.Result().StatusCode)
	validateSchema(t, delete{{capitalize (trimS .AppName)}}Schema200, getResponseBody(t, rec))

	// verify the delete
	rec = httptest.NewRecorder()
	router.ServeHTTP(rec, createNewRequest(t, http.MethodGet, fmt.Sprintf("/{{.AppName}}/%d", created{{capitalize (trimS .AppName)}}.{{capitalize (trimS .AppName)}}.ID), nil))
	assert.Equal(t, http.StatusNotFound, rec.Result().StatusCode)
	respBody = getResponseBody(t, rec)
	validateSchema(t, {{trimS .AppName}}Schema404, respBody)
}
